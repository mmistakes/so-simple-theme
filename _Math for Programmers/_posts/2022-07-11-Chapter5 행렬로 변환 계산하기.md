---
title: Chapter5 행렬로 변환 계산하기
date: 2022-07-11
categories:
- Chapter 5
---


#### 격자 모양으로 적절히 배열한 9개의 수는 일차변환을 실행하는 방법을 설명해준다. 
#### 이것을 행렬(Matrix)으로 부른다. 
#### 행렬은 일차변환이 표준 기저 벡터에 작용한 결과 데이터를 사용하여 해당 일차변환을 계산 할 수 있게 한다.

----------------------------

## 5.1 행렬로 일차변환 표현하기
 
### 5.1.1. 벡터와 일차변환을 행렬로 표현하기 
#### 행렬은 수로 만든 직사각형 격자로, 그 모양이 행렬의 해석방법을 알려준다.
#### 열이 하나뿐인 행렬은 벡터로 볼 수 있다. 이때 벡터의 각 성분은 좌표를 나타낸다. 이런 벡터를 열벡터라고 한다.
#### 일차변환에서 행렬을 얻는 방법은 모든 표준 기저 벡터에 일차변환을 수행해 얻은 벡터들을 나란히 배치해 결합을 얻는 것이다.
----------------------------
### 5.1.2 행렬과 벡터 곱하기 

#### 일차변환 B와 벡터 v를 행렬(열벡터)로 표현한다고 나면 B(v)를 구하는데 필요한 모든 수를 알 수 있다.
#### v(3,-2,5)라고 하면 v = 3e1 - 2e2 + 5e3가 된다. B = ((0,2,1), (0,1,0), (1,0,-1))라고 하면 B(v) = ((1,-2,-2)) 가 된다.
#### 행렬곱셈이라는 연산을 사용하면 정사각행렬을 열벡터에 작용하는 함수처럼 만들 수 있다.


```python
B = (
    (0,2,1),
    (0,1,0),
    (1,0,-1))
v = (-3,-2,5)

```


```python
list(zip(*B)) # 열 구할 떄
```




    [(0, 0, 1), (2, 1, 0), (1, 0, -1)]




```python
from vectors import *
def linear_combination(scalars,*vectors):
 scaled = [scale(s,v) for s,v in zip(scalars,vectors)]
 return add(*scaled)

def multiply_matrix_vector(matrix, vector):
    return linear_combination(vector, *zip(*matrix))
```


```python
multiply_matrix_vector(B,v)
```




    (1, -2, -8)



#### ((a,b,c), (d,e,f), (g,h,i)) 와 (x,y,z) 가 있다고 해보자
#### 두가지 행렬을 곱으로 나타낸다고 생각해보면
#### 첫번째로는 x,y,z 좌표를 스칼라로 하여 행렬의 열을 일차결합한 것 처럼 표현할 수 있을 것이다.
#### x * (a,d,g) + y * (b,e,h) + z * (c,f,i) = ((ax+by+cz), (dx+ey+fz), (gx+hy+iz))으로 표현할 수 있다.
#### 여기서 연상할 수 있는 것은 출력벡터의 각 좌표가 입력벡터의 각 좌표의 함수라는 것이다.
#### 3차원 출력 벡터의 첫 번째 좌표는 함수 f(x,y,z) = ax + by + cz가 된다. 즉 일차함수로 나타낼 수 있다는 것이다.
#### 다시 말하면 일차변환은 입력 좌표에 대해 출력 좌표를 알려주는 일차함수들의 집합이라고 할 수 있다.
#### 두번째 연상법은 출력벡터의 좌표가 행렬의 행과 목표 벡터의 내적으로 보는 것이다. 
#### 3행 3열 행렬의 1행은 (a,b,c)이고 곱을 할 벡터는 (x,y,z)이므로 출력 벡터의 첫번째 좌표는 (a,b,c) * (x,y,z) = ax + by + cz가 된다.

----------------------------
### 5.1.3 행렬 곱으로 일차변환 합성하기

#### 수많은 일차변환을 서로 연결하면 새로운 일차변환이 된다. 이것을 수학 용어로 말하면 여러개의 일차변환을 합성해도 일차변환이 된다는 것이다.
#### 3 * 3 행렬과 열벡터를 곱하는 것은 내적을 3번 수행하는 것과 같다.
#### 위의 내용을 생각해보면 두개의 3 * 3행렬을 곱하는 것은 내적을 9번 수행한 것과 같은 결과가 나온다는 것을 알 수 있다.
----------------------------
### 5.1.4 행렬 곱 구현하기 

#### 행렬 곱셈의 결과는 튜플의 튜플이 되어야 한다. 고로 컴프리헨션을 중첩해서 함수를 작성할 수 있다.
#### 입력 행렬은 a는 이미 첫번째 행렬의 행에 대한 튜플이므로 두번째 행렬의 열에 대한 튜플인 zip(*b) 와 짝을 이루게 할 수 있다.
#### 마지막으로 각 쌍에 대해 내적을 취하여 안쪽 컴프리헨션에 둔다.


```python
# 구현하기
from vectors import *
def matrix_multiply(a,b):
    return tuple(
        tuple(dot(row,col) for col in zip(*b))
        for row in a)
```


```python
# 구현한것 확인하기
a = ((1,1,0), (1,0,1), (1,-1,-1))
b = ((0,2,1), (0,1,0), (1,0,-1))
print(matrix_multiply(a,b))

c = ((1,2), (3,4))
d = ((0,-1), (1,0))
print(matrix_multiply(c,d)) # 2*2 행렬에도 동일하게 적용됨.
```

    ((0, 3, 1), (1, 2, 0), (-1, 1, 2))
    ((2, -1), (4, -3))
    
----------------------------
### 5.1.5 행렬 변환을 통한 3차원 애니메이션  

#### 시간이 지남에 따라 모델이 움직이거나 변화하는 것처럼 보이도록 하려면 시간이 경과함에 따라 다른 변환을 사용할 필요가 있다.
#### PyGame을 이용해 현재 시간 t를 입력으로 받아 수를 리턴하는 함수를 만들 수 있다.



```python
# 구현
from teapot import load_triangles
from draw_model import draw_model
from math import sin,cos

def get_rotation_matrix(t): 
    seconds = t/1000 # 시간을 초단위로 만들어 변환 속도 조절
    return (
        (cos(seconds),0,-sin(seconds)),
        (0,1,0),
        (sin(seconds),0,cos(seconds))
    )

```


```python
def multiply_matrix_vector(matrix, vector):
    return linear_combination(vector, *zip(*matrix))

!python animate_teapot.py

```
