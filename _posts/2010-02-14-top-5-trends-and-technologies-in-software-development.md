---
layout: post
title: "Top 5 Trends and Technologies in Software Development"
category: posts
permalink: "top-5-trends-in-software-development"
featured_image: /images/The_ninja_by_guruji.jpg
category: posts
description: "In this ever-changing world of software development it's extremely important to keep up with current technologies, methodologies and trends."
keywords:
- it trends
- technology trends
comments: true
share: true
image:
  social: 
  social_thumb: 
---

In this ever-changing world of software development it’s extremely important to keep up with current technologies, methodologies and trends. 


It can easily get out of hand though – simply there’s not enough time for anyone to learn all new stuff, work and live a normal life simultaneously. Selection is thus the key, being smartly selective about new things to learn so we won’t miss important stuff but also keep ‘junk’ or unimportant trends out. I created this small and ever-incomplete list of things I feel we all should pay attention to and practice. Some items could be considered ‘old’ (read: more than a few months old) but still not grasped enough yet. Without further ado I present thee the list:

## Learn and use a modern scripting language
It can be Ruby, Python, Groovy or TheNextBigShot coming along, it doesn’t really matter. What matters is having a quick and easy tool for anything at hand so we won’t have to fire up our java IDE for a simple script. Also (most of) these languages encourage good pracices and methods, changing our attitude towards programming and program design. Embracing these “wow, look how elegant and simple that is!” solutions also become expectations with time (because we’ll get used to the ease and convenience), thus we will be striving for elegance and quality – helping impoving all of our further designs and codes. 

## Learn thogoughly and embrace the philosophy of a modern version control system
Be it Git or Mercurial, but start using them. Right now. Embrace the paradigm shift that gave birth to these tools. If not at work then try any of these on a personal project. These tools fit better to a natural cycle of development than our old tools svn or cvs. Being distributed does not mean they can’t be used as a central company repo solution. They both encourage the concept of cheap local branching, keeping you safe by being able to revert any time (as traditional VCSes) and also keeping the central main repo clean of nitty-gritty details.


## Be familiar with NoSQL solutions like MongoDB, CouchDB.
These beasts can be a real life-saver when traditional relational DBs reach their limits at scaling and performance. Both MongoDB and CouchDB are what’s called a ‘document-oriented database’ which means that instead of rigid schemas the structure of each row is taken into account – they don’t even have to have the same fields, etc. The concept of ‘row’ becomes the concept of ‘document’. JSON-like data structures, dynamic queries, efficient storage of binary data (like videos, images), mapreduce support account for their robust and easy use-cases.

## Learn a functional language – or more than one.
It’s about the paradigm shift and philosophy again. The more things you see and use the more complete you repertoire will become. Object-oriented / imperative design is not the only one out there. Take a look at Erlang for starters, it’s easy to learn and with it you can dip your toe in the water, but for more serious stuff Haskell or OCamlis a must (I vote for Haskell though). I’d say learning a functional language is not an option anymore – it’s a must. Some problems can be solved in an insanely easy manner with a functional approach and for example Haskell can easily implement any mathematic definition or problem you’d be having a problem describing in any imperative language. Also GHC (The Glasgow Haskell Compiler) is a state of the art optimizing compiler, one of the best compiler available now. Of course Haskell is not only for scientists, many good libraries are coming out written in haskell. Also see Real world Haskellfor a nice intro. Erlang is well known for its fault tolerance, concurrency paradigms, hot-swappable code and exceptional networking support. Having such a tool at hand is always a bonus.

## Study agile methods and concepts.
Agile management is not only for managers. There’s a need for the whole team to have a good understanding about their own development and management process. Agile helps to standardize management and daily programmer work, enforcing a small, controllable devel/release/testing cycle and also encouraging good communication all across the team (actually agile just can’t work without good communicatiion!). Just look at the Agile manifesto. Some important derivatives and parts of agile methods:

* TDD - Test Driven Development
* Iteration-based development – deliver less but more frequently in well-defined short bursts
* BDD - Behavior Driven Development
* XP - Extreme Programming
* CI - Continuous Integration
* Scrum
